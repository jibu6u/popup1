<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Single‑Sphere Binocular Trainer — Primitives + 2D Image Planes (L/R Uploads)</title>
<style>
  :root{--bg:#0a0f14;--fg:#e7f0ff;--muted:#9fb3c7;--card:#121821}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Noto Sans KR,Helvetica,Arial,sans-serif}
  #ui{position:fixed;left:10px;top:10px;background:#121821cc;padding:10px;border-radius:12px;border:1px solid #223449;max-width:980px;z-index:10;max-height:calc(100vh - 20px);overflow:auto}
  #ui label{display:flex;gap:8px;align-items:center;font-size:13px;margin:6px 0}
  #ui input[type=range]{width:100%}
  #ui input[type=number]{width:90px}
  #ui button,#ui select{background:#182536;color:var(--fg);border:1px solid #2b435f;border-radius:8px;padding:6px 8px;cursor:pointer}
  #ui button:hover{background:#1f3046}
  #hud{position:fixed;left:10px;bottom:10px;background:#0009;padding:6px 8px;border-radius:10px;font-size:12px;z-index:9}
  #sbsLabels{position:fixed;top:8px;left:0;right:0;display:flex;justify-content:space-between;pointer-events:none;z-index:8}
  .pill{background:#0009;border:1px solid #335;padding:4px 8px;border-radius:999px;font-size:12px}
  .pill.L{margin-left:12%;color:#ffb3b3;border-color:#553}
  .pill.R{margin-right:12%;color:#b3e6ff;border-color:#355}
  canvas#webgl{display:block;width:100vw;height:100vh}
  #popControls{display:flex;gap:8px;align-items:center;margin-top:8px;flex-wrap:wrap}
  #popStatus{flex:0 0 72px;width:72px;height:30px;display:flex;align-items:center;justify-content:center;font-weight:700;border-radius:8px;background:#072029;color:#7bd1ff;border:1px solid #0b3e4a;font-size:12px;box-sizing:border-box}
  .muted{color:var(--muted);font-size:12px}
  .small{font-size:12px}
  .upload-list{font-size:12px;color:var(--muted);margin-top:4px}
  .col{display:flex;flex-direction:column;gap:6px}
</style>
</head>
<body>
<div id="ui">
  <div style="font-size:15px;margin-bottom:6px"><b>Single‑Sphere Binocular Trainer</b> — 프리미티브 + 2D 이미지 평면(L/R 업로드)</div>

  <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px">
    <button id="btnStart">▶ Start Preview (SxS)</button>
    <button id="btnStop">⏸ Pause</button>
    <label>미리보기
      <select id="previewMode">
        <option value="sbs" selected>Side‑by‑Side (PC)</option>
        <option value="mono">단일 뷰 (디버그)</option>
      </select>
    </label>
  </div>

  <fieldset style="margin-top:8px">
    <legend>소스 선택</legend>
    <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
      <label>소스
        <select id="source" style="min-width:260px">
          <option value="primitive" selected>Primitive (프리미티브)</option>
          <option value="image_pair">Uploaded Image (L/R 이미지)</option>
          <!-- uploaded individual images are no longer single-source items; image_pair handles L/R -->
        </select>
      </label>

      <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
        <div class="col">
          <label>왼쪽 이미지 업로드 (2D)
            <input id="uploadImageL" type="file" accept=".jpg,.jpeg,.png">
          </label>
          <div id="uploadedL" class="upload-list muted">왼쪽 이미지 없음</div>
        </div>

        <div class="col">
          <label>오른쪽 이미지 업로드 (2D)
            <input id="uploadImageR" type="file" accept=".jpg,.jpeg,.png">
          </label>
          <div id="uploadedR" class="upload-list muted">오른쪽 이미지 없음</div>
        </div>

        <div style="display:flex;flex-direction:column;gap:6px;margin-left:6px">
          <label style="align-items:center"><input id="usePerEyeTexturesOption" type="checkbox"> Use per-eye primitive textures (프리미티브용 좌/우 텍스쳐 적용 가능)</label>
          <div class="muted small">이미지 페어(source=image_pair) 선택 시, 좌/우 별 이미지를 업로드하세요. "Use per-eye primitive textures" 체크 시 프리미티브에서 texL/texR 사용 가능.</div>
        </div>
      </div>
    </div>
  </fieldset>

  <fieldset style="margin-top:8px">
    <legend>프리미티브</legend>
    <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px">
      <label>모양
        <select id="primitive">
          <option value="sphere" selected>Sphere</option>
          <option value="box">Box</option>
          <option value="cylinder">Cylinder</option>
          <option value="plane">Plane</option>
        </select>
      </label>
      <label>크기(scale) <input id="primSize" type="range" min="0.2" max="2" step="0.01" value="0.9"></label>
      <label>자동회전 <input id="autoRotate" type="checkbox" checked></label>
    </div>
  </fieldset>

  <fieldset style="margin-top:8px">
    <legend>텍스쳐 & 필터 (프리미티브 전용 / 좌/우)</legend>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px">
      <label>좌 텍스쳐 (텍스쳐는 프리미티브에만 적용)
        <input id="texL" type="file" accept=".jpg,.jpeg,.png">
      </label>
      <label>우 텍스쳐 (텍스쳐는 프리미티브에만 적용)
        <input id="texR" type="file" accept=".jpg,.jpeg,.png">
      </label>
    </div>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:6px">
      <div style="border:1px solid #2b435f;border-radius:10px;padding:8px">
        <div style="font-weight:600;color:#ffb3b3;margin-bottom:4px">Left</div>
        <label>Luminance <input id="lumL" type="range" min="0.2" max="2" step="0.01" value="1.0"></label>
        <label>Contrast  <input id="conL" type="range" min="0" max="2" step="0.01" value="1.0"></label>
      </div>
      <div style="border:1px solid #2b435f;border-radius:10px;padding:8px">
        <div style="font-weight:600;color:#b3e6ff;margin-bottom:4px">Right</div>
        <label>Luminance <input id="lumR" type="range" min="0.2" max="2" step="0.01" value="1.0"></label>
        <label>Contrast  <input id="conR" type="range" min="0" max="2" step="0.01" value="1.0"></label>
      </div>
    </div>
  </fieldset>

  <fieldset style="margin-top:8px">
    <legend>팝아웃 (Up / Hold / Down 루프)</legend>
    <div id="popControls">
      <label>팝 대상<select id="popEye"><option value="L">Left</option><option value="R">Right</option></select></label>
      <label>팝 거리 (m) <input id="popAmount" type="range" min="0" max="0.6" step="0.005" value="0.08"></label>
      <label>올라가는 시간 (s) <input id="popTime" type="number" min="0.01" step="0.01" value="0.45" style="width:80px"></label>
      <label>유지 시간 (s) <input id="holdTime" type="number" min="0" step="0.01" value="0.6" style="width:80px"></label>
      <div id="popStatus">idle</div>
    </div>
    <div class="muted small" style="margin-top:6px">이미지 페어로 선택했을 때도 좌/우 각각 팝아웃 적용됩니다 (선택한 팝 대상에 따라 좌 또는 우 평면이 앞으로 이동).</div>
  </fieldset>

  <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:8px">
    <button id="enterVR">Enter VR</button>
    <button id="exitVR">Exit VR</button>
  </div>
</div>

<div id="sbsLabels"><span class="pill L">LEFT</span><span class="pill R">RIGHT</span></div>
<canvas id="webgl"></canvas>
<div id="hud">—</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.149.0/build/three.min.js"></script>
<script>
(function(){
  'use strict';
  const $ = id => document.getElementById(id);

  // Renderer + scene
  const renderer = new THREE.WebGLRenderer({ canvas: $('webgl'), antialias:true, alpha:false });
  renderer.xr.enabled = true;
  renderer.outputEncoding = THREE.sRGBEncoding;
  // prefer a standing/local-floor reference space in XR sessions
  renderer.xr.setReferenceSpaceType && renderer.xr.setReferenceSpaceType('local-floor');

  // ensure touch / pointer behavior doesn't conflict with WebXR
  renderer.domElement.style.touchAction = 'none';

  function fit(){ const dpr=Math.min(2,window.devicePixelRatio||1); renderer.setPixelRatio(dpr); renderer.setSize(window.innerWidth, window.innerHeight, false); }
  window.addEventListener('resize', fit);
  fit();

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.01, 100);
  camera.position.set(0,0,2.2);

  const amb = new THREE.AmbientLight(0xffffff, 0.7); scene.add(amb);
  const dir = new THREE.DirectionalLight(0xffffff, 0.9); dir.position.set(3,5,4); scene.add(dir);
  const lightDir = new THREE.Vector3().copy(dir.position).normalize();

  const fusionGroup = new THREE.Group(); scene.add(fusionGroup);
  const LAYER_L = 1, LAYER_R = 2;

  // state
  let meshL = null, meshR = null;
  let uploadedL = null, uploadedR = null; // {url,width,height,name}
  const texLoader = new THREE.TextureLoader(); texLoader.setCrossOrigin('anonymous');

  // primitive shader (same simple shader used earlier)
  function commonUniforms(){ return {
    uMap:{value:null}, uHasMap:{value:0},
    uLum:{value:1.0}, uCon:{value:1.0}, uTint:{value:new THREE.Vector3(0,0,0)},
    uLightDir:{value:lightDir.clone()}, uBaseColor:{value:new THREE.Color(0xffffff)}, uGamma:{value:2.2}
  }; }
  const vert = `varying vec2 vUv; varying vec3 vN; void main(){ vUv=uv; vN=normalize(normalMatrix*normal); gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }`;
  const frag = `
    uniform sampler2D uMap; uniform int uHasMap; uniform float uLum, uCon, uGamma; uniform vec3 uTint; uniform vec3 uLightDir; uniform vec3 uBaseColor;
    varying vec2 vUv; varying vec3 vN;
    float satf(float x){ return clamp(x,0.0,1.0); }
    vec3 rgb2hsv(vec3 c){ float cmax=max(c.r,max(c.g,c.b)); float cmin=min(c.r,min(c.g,c.b)); float d=cmax-cmin; float h=0.0;
      if(d>1e-5){ if(cmax==c.r) h=mod((c.g-c.b)/d,6.0); else if(cmax==c.g) h=(c.b-c.r)/d+2.0; else h=(c.r-c.g)/d+4.0; }
      float s=cmax==0.0?0.0:d/cmax; return vec3(60.0*h,s,cmax);
    }
    vec3 hsv2rgb(vec3 h){ float H=h.x/60.0; float S=h.y; float V=h.z; float C=V*S; float X=C*(1.0-abs(mod(H,2.0)-1.0)); vec3 rgb=(H<1.0?vec3(C,X,0.0):H<2.0?vec3(X,C,0.0):H<3.0?vec3(0.0,C,X):H<4.0?vec3(0.0,X,C):H<5.0?vec3(X,0.0,C):vec3(C,0.0,X)); float m=V-C; return rgb+vec3(m); }
    void main(){
      vec3 base = uHasMap==1 ? texture2D(uMap,vUv).rgb : uBaseColor;
      base = (base-0.5)*uCon + 0.5;
      base *= uLum;
      if(uTint.z>0.001){ vec3 hv=rgb2hsv(base); hv.x = mod(uTint.x,360.0); hv.y = clamp(hv.y+uTint.y,0.0,1.0); vec3 tc=hsv2rgb(hv); base = mix(base,tc,clamp(uTint.z,0.0,1.0)); }
      float lam = max(0.0, dot(normalize(vN), normalize(uLightDir)));
      vec3 col = base * (0.35 + 0.65 * lam);
      col = pow(col, vec3(1.0/uGamma));
      gl_FragColor = vec4(satf(col.r), satf(col.g), satf(col.b), 1.0);
    }
  `;
  function makePrimitiveMaterial(){ return new THREE.ShaderMaterial({uniforms:commonUniforms(), vertexShader:vert, fragmentShader:frag, lights:false, fog:false, transparent:false, side:THREE.DoubleSide}); }

  // helpers to create geometry
  function buildPrimitiveGeo(kind,size){
    const s = Math.max(0.05,size);
    switch(kind){
      case 'sphere': return new THREE.SphereGeometry(s*0.5,64,40);
      case 'box': return new THREE.BoxGeometry(s,s,s);
      case 'cylinder': return new THREE.CylinderGeometry(s*0.5,s*0.5,s,64,1,false);
      case 'plane': return new THREE.PlaneGeometry(s,s,1,1);
      default: return new THREE.SphereGeometry(s*0.5,64,40);
    }
  }

  function disposeMesh(m){
    if(!m) return;
    if(m.geometry) m.geometry.dispose();
    if(m.material){ if(Array.isArray(m.material)) m.material.forEach(x=>x.dispose()); else m.material.dispose(); }
  }

  function clearFusion(){
    if(meshL){ fusionGroup.remove(meshL); disposeMesh(meshL); meshL=null; }
    if(meshR){ fusionGroup.remove(meshR); disposeMesh(meshR); meshR=null; }
  }

  // build primitives overlapped for L/R
  function buildFusionFromPrimitive(kind,size){
    clearFusion();
    const geo = buildPrimitiveGeo(kind,size);
    const matL = makePrimitiveMaterial(), matR = makePrimitiveMaterial();
    meshL = new THREE.Mesh(geo, matL); meshL.layers.set(LAYER_L);
    meshR = new THREE.Mesh(geo.clone ? geo.clone() : geo, matR); meshR.layers.set(LAYER_R);
    meshL.userData.basePos = meshL.position.clone(); meshR.userData.basePos = meshR.position.clone();
    fusionGroup.add(meshL); fusionGroup.add(meshR);
  }

  // build image planes for L/R uploaded images
  function buildFusionFromImagePair(){
    clearFusion();
    const primSize = +$('primSize').value || 0.9;
    const leftMeta = uploadedL, rightMeta = uploadedR;
    // If neither image exists, do nothing
    if(!leftMeta && !rightMeta){ alert('왼쪽 또는 오른쪽 이미지를 업로드하세요.'); return; }
    // We'll create two planes sized by their native aspect ratios (or default square)
    function makePlaneFromMeta(meta){
      const aspect = (meta && meta.width && meta.height) ? (meta.width/meta.height) : 1.0;
      const h = primSize; const w = primSize * aspect;
      const geo = new THREE.PlaneGeometry(w,h);
      const mat = new THREE.MeshBasicMaterial({ map: meta ? texLoader.load(meta.url) : null, side: THREE.DoubleSide });
      return {geo,mat};
    }
    const left = makePlaneFromMeta(leftMeta), right = makePlaneFromMeta(rightMeta);
    meshL = new THREE.Mesh(left.geo, left.mat); meshL.layers.set(LAYER_L); meshL.userData.isImagePlane = true; meshL.userData.basePos = meshL.position.clone();
    meshR = new THREE.Mesh(right.geo, right.mat); meshR.layers.set(LAYER_R); meshR.userData.isImagePlane = true; meshR.userData.basePos = meshR.position.clone();
    fusionGroup.add(meshL); fusionGroup.add(meshR);
  }

  // handle uploads for L/R images
  $('uploadImageL').addEventListener('change', (e)=>{
    const f = e.target.files && e.target.files[0];
    if(!f) return;
    if(!f.name.match(/\.(jpe?g|png)$/i)){ alert('JPG/JPEG/PNG만 지원합니다'); return; }
    const url = URL.createObjectURL(f);
    const img = new Image();
    img.onload = ()=>{ uploadedL = {url, width: img.naturalWidth, height: img.naturalHeight, name: f.name}; $('uploadedL').textContent = f.name; if($('source').value === 'image_pair') buildFusionFromImagePair(); };
    img.onerror = ()=>{ alert('왼쪽 이미지 로드 실패'); URL.revokeObjectURL(url); };
    img.src = url;
  });
  $('uploadImageR').addEventListener('change', (e)=>{
    const f = e.target.files && e.target.files[0];
    if(!f) return;
    if(!f.name.match(/\.(jpe?g|png)$/i)){ alert('JPG/JPEG/PNG만 지원합니다'); return; }
    const url = URL.createObjectURL(f);
    const img = new Image();
    img.onload = ()=>{ uploadedR = {url, width: img.naturalWidth, height: img.naturalHeight, name: f.name}; $('uploadedR').textContent = f.name; if($('source').value === 'image_pair') buildFusionFromImagePair(); };
    img.onerror = ()=>{ alert('오른쪽 이미지 로드 실패'); URL.revokeObjectURL(url); };
    img.src = url;
  });

  // when source changes
  $('source').addEventListener('change', ()=>{
    const v = $('source').value;
    if(v === 'primitive'){
      buildFusionFromPrimitive($('primitive').value, +$('primSize').value);
    } else if(v === 'image_pair'){
      buildFusionFromImagePair();
    }
  });

  // primitive changes
  $('primitive').addEventListener('change', ()=>{ if($('source').value==='primitive') buildFusionFromPrimitive($('primitive').value, +$('primSize').value); });
  $('primSize').addEventListener('input', ()=>{ if($('source').value==='primitive') buildFusionFromPrimitive($('primitive').value, +$('primSize').value); else if($('source').value==='image_pair') buildFusionFromImagePair(); });

  // apply primitive textures (left/right) only when option is toggled
  function setPrimitiveTexture(eye, file){
    if(!file) return;
    const reader = new FileReader();
    reader.onload = ()=> {
      const url = reader.result;
      texLoader.load(url, (tex)=>{
        tex.encoding = THREE.sRGBEncoding; tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
        tex.minFilter = THREE.LinearMipMapLinearFilter; tex.magFilter = THREE.LinearFilter; tex.generateMipmaps = true; tex.needsUpdate = true;
        if($('usePerEyeTexturesOption').checked){
          const target = eye === 'L' ? meshL : meshR;
          if(!target){ console.warn('대상 메쉬 없음'); return; }
          // if primitive shader (has uniforms) set uMap, otherwise set material.map
          if(target.material && target.material.uniforms){
            target.material.uniforms.uMap.value = tex; target.material.uniforms.uHasMap.value = 1; target.material.needsUpdate = true;
          } else if(target.material){
            target.material.map = tex; target.material.needsUpdate = true;
          }
        } else {
          // option off -> do nothing (textures intended for primitives only)
          alert('Use per-eye primitive textures 옵션이 꺼져 있습니다. 옵션을 켜면 프리미티브에 적용됩니다.');
        }
      }, undefined, (err)=>{ console.error(err); alert('텍스쳐 로드 실패'); });
    };
    reader.readAsDataURL(file);
  }
  $('texL').addEventListener('change', (e)=>{ const f = e.target.files && e.target.files[0]; if(f) setPrimitiveTexture('L', f); });
  $('texR').addEventListener('change', (e)=>{ const f = e.target.files && e.target.files[0]; if(f) setPrimitiveTexture('R', f); });

  // Pop loop
  let running=false, lastT=performance.now(), popClock=0;
  function updatePop(dt){
    const popTime = Math.max(0.0001, +$('popTime').value);
    const holdTime = Math.max(0, +$('holdTime').value);
    const cycle = popTime + holdTime + popTime;
    if(cycle <= 0.0001 || (!meshL && !meshR)){ $('popStatus').textContent = 'idle'; return; }
    popClock += dt;
    const t = popClock % cycle;
    let state='idle', curAmount=0;
    if(t < popTime){ state='up'; const p = t/popTime; const ease=(1 - Math.cos(Math.PI * p))/2; curAmount = ease * +$('popAmount').value; }
    else if(t < popTime + holdTime){ state='hold'; curAmount = +$('popAmount').value; }
    else { state='down'; const q = (t - popTime - holdTime)/popTime; curAmount = (1 - q) * +$('popAmount').value; }
    $('popStatus').textContent = state;

    // compute direction from fusionGroup to camera
    const fusionWorldPos = fusionGroup.getWorldPosition(new THREE.Vector3());
    const camWorldPos = camera.getWorldPosition(new THREE.Vector3());
    const dir = camWorldPos.sub(fusionWorldPos).normalize();
    const worldTarget = fusionWorldPos.clone().add(dir.multiplyScalar(curAmount));
    const localTarget = fusionGroup.worldToLocal(worldTarget.clone());

    const popEye = $('popEye').value;
    if(meshL){
      const baseL = meshL.userData.basePos || new THREE.Vector3();
      if(popEye === 'L') meshL.position.copy(baseL).add(localTarget); else meshL.position.copy(baseL);
    }
    if(meshR){
      const baseR = meshR.userData.basePos || new THREE.Vector3();
      if(popEye === 'R') meshR.position.copy(baseR).add(localTarget); else meshR.position.copy(baseR);
    }
  }

  // render loop (SxS)
  function renderLoop(t){
    if(!running) return;
    const dt = (t - lastT)/1000; lastT = t;

    // if image planes, billboard them to camera
    if($('source').value === 'image_pair'){
      if(meshL && meshL.userData.isImagePlane) meshL.quaternion.copy(camera.quaternion);
      if(meshR && meshR.userData.isImagePlane) meshR.quaternion.copy(camera.quaternion);
    } else {
      if($('autoRotate').checked) fusionGroup.rotation.y += dt * (+$('primSize') || 0.4);
    }

    updatePop(dt);

    const w = renderer.domElement.width, h = renderer.domElement.height;
    renderer.setScissorTest(false); renderer.clear();

    if($('previewMode').value === 'sbs'){
      const half = w >> 1;
      // left
      camera.aspect = half/h; camera.updateProjectionMatrix();
      renderer.setScissorTest(true);
      renderer.setViewport(0,0,half,h); renderer.setScissor(0,0,half,h);
      camera.layers.set(LAYER_L); renderer.render(scene, camera);
      // right
      renderer.setViewport(half,0,half,h); renderer.setScissor(half,0,half,h);
      camera.layers.set(LAYER_R); renderer.render(scene, camera);
      camera.layers.set(0);
      renderer.setScissorTest(false);
    } else {
      camera.aspect = w/h; camera.updateProjectionMatrix();
      renderer.setViewport(0,0,w,h);
      camera.layers.enable(LAYER_L); camera.layers.enable(LAYER_R);
      renderer.render(scene, camera);
      camera.layers.set(0);
    }

    requestAnimationFrame(renderLoop);
  }

  $('btnStart').addEventListener('click', ()=>{ if(!running){ running=true; lastT=performance.now(); requestAnimationFrame(renderLoop); }});
  $('btnStop').addEventListener('click', ()=>{ running=false; });

  // VR enter/exit (improved for broader device support)
  let xrSession = null;
  $('enterVR').addEventListener('click', async ()=>{
    try{
      if(!navigator.xr){ alert('WebXR 미지원(브라우저/플랫폼에서 WebXR API를 찾을 수 없습니다). HTTPS로 호스트하거나 WebXR 지원 브라우저에서 실행하세요.'); return; }

      // Prefer immersive-vr but try to detect support robustly
      const supportsVR = await navigator.xr.isSessionSupported('immersive-vr').catch(()=>false);
      if(!supportsVR){
        // fallback hint: try immersive-ar or show a friendly message
        const supportsAR = await navigator.xr.isSessionSupported('immersive-ar').catch(()=>false);
        if(supportsAR){
          if(!confirm('디바이스는 immersive-vr 를 지원하지 않지만 immersive-ar 를 지원합니다. AR 모드로 전환하시겠습니까?')) return;
        } else {
          alert('이 기기/브라우저는 immersive VR 세션을 지원하지 않습니다. WebXR을 지원하는 최신 브라우저(Chrome/Edge 등)와 VR 헤드셋을 사용하거나 WebXR 폴리필을 확인하세요.');
          return;
        }
      }

      // Request session with several optional features to increase the chance of success
      const sessionInit = {
        optionalFeatures: ['local-floor','bounded-floor','hand-tracking','layers','viewer','dom-overlay'],
        // domOverlay requires a root if used; include it only as optional and provide root if available
        domOverlay: { root: document.body }
      };

      // request immersive-vr but allow exceptions to be caught
      xrSession = await navigator.xr.requestSession('immersive-vr', sessionInit).catch(async (err)=>{
        // If immersive-vr failed, try immersive-ar as a fallback (if supported)
        console.warn('immersive-vr request failed:', err);
        const arSupported = await navigator.xr.isSessionSupported('immersive-ar').catch(()=>false);
        if(arSupported){
          return await navigator.xr.requestSession('immersive-ar', sessionInit);
        }
        throw err;
      });

      // Ensure reference space type preference is set (three.js will use this)
      renderer.xr.setReferenceSpaceType && renderer.xr.setReferenceSpaceType('local-floor');

      // Attach session to three.js renderer
      await renderer.xr.setSession(xrSession);

      // set lastT to avoid huge dt on session start
      lastT = performance.now();

      // Configure the XR cameras' layers so each eye sees its layer (if array camera is available)
      const xrCam = renderer.xr.getCamera ? renderer.xr.getCamera(camera) : null;
      if(xrCam && xrCam.isArrayCamera && xrCam.cameras && xrCam.cameras.length >= 2){
        // ensure consistent mapping: left eye camera -> LAYER_L, right -> LAYER_R
        // Do this now and also in the animation loop because some devices recreate cameras
        xrCam.cameras[0].layers.enable(LAYER_L); xrCam.cameras[0].layers.disable(LAYER_R);
        xrCam.cameras[1].layers.enable(LAYER_R); xrCam.cameras[1].layers.disable(LAYER_L);
      }

      // Use three.js animation loop for XR. It will call this callback with a high-res timestamp.
      renderer.setAnimationLoop((now)=>{
        // keep lastT updated for pop timing (use performance.now()-based dt)
        const dt = (now - lastT) / 1000;
        lastT = now;

        // per-frame: update pop and billboards
        if(running) updatePop(dt);

        // billboard in XR too: get an XR-aware camera (three.js supplies it to renderer.render)
        if($('source').value === 'image_pair'){
          const xrCamera = renderer.xr.getCamera ? renderer.xr.getCamera(camera) : camera;
          if(meshL && meshL.userData.isImagePlane) meshL.quaternion.copy(xrCamera.quaternion || camera.quaternion);
          if(meshR && meshR.userData.isImagePlane) meshR.quaternion.copy(xrCamera.quaternion || camera.quaternion);
        } else {
          if($('autoRotate').checked) fusionGroup.rotation.y += dt * (+$('primSize') || 0.4);
        }

        // Ensure per-eye layers remain set each frame in case the XR camera structure was updated by the runtime
        const xrCameraNow = renderer.xr.getCamera ? renderer.xr.getCamera(camera) : null;
        if(xrCameraNow && xrCameraNow.isArrayCamera && xrCameraNow.cameras){
          if(xrCameraNow.cameras.length >= 2){
            xrCameraNow.cameras[0].layers.enable(LAYER_L); xrCameraNow.cameras[0].layers.disable(LAYER_R);
            xrCameraNow.cameras[1].layers.enable(LAYER_R); xrCameraNow.cameras[1].layers.disable(LAYER_L);
          }
        }

        // Render; three.js will handle XR framebuffer and view/projection for each eye
        renderer.render(scene, camera);
      });

      // clean up on session end
      xrSession.addEventListener('end', ()=>{
        renderer.setAnimationLoop(null);
        xrSession = null;
        // reset lastT to avoid big dt on resume
        lastT = performance.now();
      });
    }catch(e){
      console.error('VR 진입 오류:', e);
      alert('VR 진입 오류: ' + (e && e.message ? e.message : e));
    }
  });

  $('exitVR').addEventListener('click', async ()=>{
    try{
      if(xrSession) await xrSession.end();
    }catch(e){
      console.warn('XR 세션 종료 실패', e);
    }
  });

  // initialize with primitive
  buildFusionFromPrimitive('sphere', +$('primSize').value);

  // --- 핵심 추가: 초기 렌더가 빈 화면(검은 화면)이 되는 것을 막기 위해
  // 카메라에서 좌/우 레이어를 기본으로 활성화하고 한 프레임 렌더링합니다.
  camera.layers.enable(LAYER_L);
  camera.layers.enable(LAYER_R);
  renderer.render(scene, camera);
  // --- 끝

})();
</script>
</body>
</html>